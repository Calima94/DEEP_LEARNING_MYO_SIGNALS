from train_emg_data import Ui_Form
from PyQt5 import QtCore, QtWidgets, QtGui
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import roc_curve
from sklearn.metrics import roc_auc_score
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.pyplot as plt
import sys
import pandas as pd
import numpy as np
import train_signals_emg
import os
from param_to_use import ParametersToUse
import ast

# Define the desired columns for EMG data
COLUMNS_DESIRED = ["time", "chanel1", "chanel2", "chanel3", "chanel4"]

class EmgApplication(QtWidgets.QWidget, Ui_Form):
    def __init__(self, parent=None) -> None:
        # Initiate class and Ui_Form generated by PyQt5 Designer
        super().__init__(parent)
        # Set the configurations of the file generated by PyQt5 Designer
        self.setupUi(self)
        
        # Load parameters from param_to_use.py
        self.params = ParametersToUse()

        # Create Canvas variables to plot the graphs
        self.canvas_main_classifier = None
        self.figure_3 = None
        self.horizontalLayout_15 = None
        self.data_and_classifiers = None
        self.horizontalLayout_5 = None
        self.figure = None
        self.canvas_raw_signals = None
        self.horizontalLayout_4 = None
        self.figure_1 = None
        self.canvas_process_signals = None
        self.horizontalLayout_16 = None
        self.figure_2 = None
        self.canvas_conf_matrix = None
        self.figure_4 = None
        self.horizontalLayout_17 = None
        self.canvas_roc_curve = None

        # create the set of canvas to plot the graphs
        self.set_of_canvas()

        # Start the program without training the classifiers
        self.trained_sys = False

        # Load default values from parameters.csv
        self.load_default_values()

        # Apply modern styling
        self.apply_modern_styling()

        # Select pages
        self.home_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.home_pg))
        self.def_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.def_pg))
        self.results_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.results_pg))
        self.contact_btn.clicked.connect(lambda: self.pages.setCurrentWidget(self.contact_pg))

        # Select the result page option
        self.plot_conf_matrix_btn.clicked.connect(lambda: self.results_pgs.setCurrentWidget(self.confusion_pg))
        self.plot_roc_curve_btn.clicked.connect(lambda: self.results_pgs.setCurrentWidget(self.roc_pg))
        self.plot_process_signals_btn.clicked.connect(
            lambda: self.results_pgs.setCurrentWidget(self.plot_processed_signals_pg))
        self.plot_raw_signals_btn.clicked.connect(
            lambda: self.results_pgs.setCurrentWidget(self.plot_raw_signals_pg))

        # Definitions buttons
        self.search_file_btn.clicked.connect(self.find_path_file)
        self.filter_1_btn.clicked.connect(self.find_path_filter_1)
        self.filter_2_btn.clicked.connect(self.find_path_filter_2)
        self.redefine_param_btn.clicked.connect(self.refresh_params)

        # Plot buttons in the results page
        self.plot_conf_matrix_btn_2.clicked.connect(self.plot_confusion_matrix)
        self.plot_roc_curve_btn_2.clicked.connect(self.plot_roc_curve)
        self.btn_plot_processed_signals.clicked.connect(self.classified_signals)
        self.plot_raw_signals_btn_2.clicked.connect(self.raw_signals_plot)

        # Train the classifiers in the home page
        self.train_all_signals.clicked.connect(self.train_myo)
        
        # Set initial page
        self.pages.setCurrentWidget(self.home_pg)
        self.results_pgs.setCurrentWidget(self.confusion_pg)

    def apply_modern_styling(self):
        """
        Apply modern styling to the application
        """
        # Set application font
        app_font = QtGui.QFont("Segoe UI", 9)
        QtWidgets.QApplication.setFont(app_font)
        
        # Define color palette
        primary_color = "#3498db"  # Blue
        secondary_color = "#2c3e50"  # Dark blue/gray
        accent_color = "#e74c3c"  # Red
        light_color = "#ecf0f1"  # Light gray
        dark_color = "#34495e"  # Darker blue/gray
        
        # Define distinct colors for Results submenu buttons
        results_colors = {
            "confusion": "#3498db",  # Blue
            "roc": "#e74c3c",        # Red
            "processed": "#2ecc71",  # Green
            "raw": "#f39c12"         # Orange
        }
        
        # Style for main window
        main_style = f"""
            QWidget {{
                background-color: {light_color};
                color: {secondary_color};
            }}
        """
        
        # Style for buttons
        button_style = f"""
            QPushButton {{
                background-color: {primary_color};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            
            QPushButton:hover {{
                background-color: #2980b9;
            }}
            
            QPushButton:pressed {{
                background-color: #1f6aa5;
            }}
        """
        
        # Style for Results submenu buttons
        results_button_style = f"""
            QPushButton#plot_conf_matrix_btn {{
                background-color: {results_colors['confusion']};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            
            QPushButton#plot_conf_matrix_btn:hover {{
                background-color: #2980b9;
                border: 2px solid white;
            }}
            
            QPushButton#plot_roc_curve_btn {{
                background-color: {results_colors['roc']};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            
            QPushButton#plot_roc_curve_btn:hover {{
                background-color: #c0392b;
                border: 2px solid white;
            }}
            
            QPushButton#plot_process_signals_btn {{
                background-color: {results_colors['processed']};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            
            QPushButton#plot_process_signals_btn:hover {{
                background-color: #27ae60;
                border: 2px solid white;
            }}
            
            QPushButton#plot_raw_signals_btn {{
                background-color: {results_colors['raw']};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px 16px;
                font-weight: bold;
            }}
            
            QPushButton#plot_raw_signals_btn:hover {{
                background-color: #d35400;
                border: 2px solid white;
            }}
        """
        
        # Style for frames
        frame_style = f"""
            QFrame {{
                border-radius: 6px;
                background-color: white;
                border: 1px solid #dcdde1;
            }}
        """
        
        # Style for labels
        label_style = f"""
            QLabel {{
                color: {secondary_color};
            }}
            
            QLabel[objectName^="title"] {{
                font-size: 16px;
                font-weight: bold;
                color: {dark_color};
            }}
        """
        
        # Style for comboboxes and line edits
        input_style = f"""
            QComboBox, QLineEdit {{
                border: 1px solid #bdc3c7;
                border-radius: 4px;
                padding: 4px;
                background-color: white;
                selection-background-color: {primary_color};
            }}
            
            QComboBox:focus, QLineEdit:focus {{
                border: 1px solid {primary_color};
            }}
            
            QComboBox::drop-down {{
                border: 0px;
                width: 20px;
            }}
            
            QComboBox::down-arrow {{
                image: url(down_arrow.png);
                width: 12px;
                height: 12px;
            }}
        """
        
        # Style for tab widgets
        tab_style = f"""
            QTabWidget::pane {{
                border: 1px solid #bdc3c7;
                border-radius: 4px;
                top: -1px;
                background-color: white;
            }}
            
            QTabBar::tab {{
                background-color: #f0f0f0;
                border: 1px solid #bdc3c7;
                border-bottom: none;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
                padding: 6px 12px;
                margin-right: 2px;
            }}
            
            QTabBar::tab:selected {{
                background-color: white;
                border-bottom: 1px solid white;
            }}
            
            QTabBar::tab:hover:!selected {{
                background-color: #e0e0e0;
            }}
        """
        
        # Style for tree widget
        tree_style = f"""
            QTreeWidget {{
                border: 1px solid #bdc3c7;
                border-radius: 4px;
                background-color: white;
                alternate-background-color: #f9f9f9;
                selection-background-color: {primary_color};
                selection-color: white;
            }}
            
            QTreeWidget::item {{
                padding: 4px;
                border-bottom: 1px solid #f0f0f0;
            }}
            
            QTreeWidget::item:selected {{
                background-color: {primary_color};
                color: white;
            }}
            
            QHeaderView::section {{
                background-color: #f0f0f0;
                padding: 4px;
                border: 1px solid #bdc3c7;
                border-radius: 0px;
                font-weight: bold;
            }}
        """
        
        # Apply styles
        self.setStyleSheet(main_style + button_style + results_button_style + frame_style + label_style + input_style + tab_style + tree_style)
        
        # Style specific pages
        self.home_pg.setStyleSheet(f"background-color: {light_color};")
        self.def_pg.setStyleSheet(f"background-color: {light_color};")
        self.results_pg.setStyleSheet(f"background-color: {light_color};")
        self.contact_pg.setStyleSheet(f"background-color: {light_color};")
        
        # Style navigation buttons
        nav_buttons = [self.home_btn, self.def_btn, self.results_btn, self.contact_btn]
        for i, btn in enumerate(nav_buttons):
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {dark_color};
                    color: white;
                    border: none;
                    border-radius: 4px;
                    padding: 10px 16px;
                    font-weight: bold;
                }}
                
                QPushButton:hover {{
                    background-color: #2c3e50;
                    border: 2px solid white;
                }}
                
                QPushButton:pressed {{
                    background-color: #1a252f;
                }}
            """)
        
        # Style action buttons
        action_buttons = [
            self.train_all_signals, self.search_file_btn, self.filter_1_btn, 
            self.filter_2_btn, self.redefine_param_btn, self.plot_conf_matrix_btn_2,
            self.plot_roc_curve_btn_2, self.btn_plot_processed_signals, self.plot_raw_signals_btn_2
        ]
        
        for btn in action_buttons:
            btn.setStyleSheet(button_style)
        
        # Add icons to buttons (if available)
        # self.home_btn.setIcon(QtGui.QIcon("home_icon.png"))
        # self.def_btn.setIcon(QtGui.QIcon("settings_icon.png"))
        # self.results_btn.setIcon(QtGui.QIcon("chart_icon.png"))
        # self.contact_btn.setIcon(QtGui.QIcon("contact_icon.png"))

    def set_of_canvas(self) -> None:
        """
        Set Canvas parameters to each graph
        """
        # Main screen
        # Raw signals Canvas
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout(self.frame_15)
        self.horizontalLayout_15.setObjectName("horizontallayout_6")
        # Canvas here
        self.figure_3 = plt.figure(facecolor='white')
        self.canvas_main_classifier = FigureCanvas(self.figure_3)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_15.addWidget(self.canvas_main_classifier)
        # end of horizontal layout

        # Raw signals Canvas
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.frame_12)
        self.horizontalLayout_5.setObjectName("horizontallayout_5")
        # Canvas here
        self.figure = plt.figure(facecolor='white')
        self.canvas_raw_signals = FigureCanvas(self.figure)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_5.addWidget(self.canvas_raw_signals)
        # end of horizontal layout

        # Processed signals Canvas
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.frame_13)
        self.horizontalLayout_4.setObjectName("horizontallayout_4")
        # Canvas here
        self.figure_1 = plt.figure(facecolor='white')
        self.canvas_process_signals = FigureCanvas(self.figure_1)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_4.addWidget(self.canvas_process_signals)
        # end of horizontal layout

        # Confusion Matrix
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout(self.frame_16)
        self.horizontalLayout_16.setObjectName("horizontallayout_16")
        # Canvas here
        self.figure_2 = plt.figure(facecolor='white')
        self.canvas_conf_matrix = FigureCanvas(self.figure_2)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_16.addWidget(self.canvas_conf_matrix)
        # end of horizontal layout

        # Roc Curve
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout(self.frame_11)
        self.horizontalLayout_17.setObjectName("horizontallayout_17")
        # Canvas here
        self.figure_4 = plt.figure(facecolor='white')
        self.canvas_roc_curve = FigureCanvas(self.figure_4)
        # end of Canvas
        # Add Canvas
        self.horizontalLayout_17.addWidget(self.canvas_roc_curve)
        # end of horizontal layout

    def load_default_values(self) -> None:
        """
        Load default values from parameters.csv into the UI elements
        """
        try:
            # Read parameters from CSV
            df = pd.read_csv("Parameters/parameters.csv", index_col="Parameter")
            
            # Set values in UI elements
            self.frequency.setText(str(df.loc["frequency_of_capture", "Value"]))
            self.window_time.setText(str(df.loc["window_time", "Value"]))
            
            # Set number of channels and update comboboxes
            n_channels = int(df.loc["n_of_channels_and_category", "Value"])
            self.n_of_channels.setCurrentText(str(n_channels))
            self.update_channel_comboboxes(n_channels)
            
            # Clear and initialize channel selection comboboxes
            self.cb_plot_channel_1_process_signals.clear()
            self.cb_plot_channel_2_process_signals.clear()
            
            # Add channel options to comboboxes
            for i in range(1, n_channels + 1):
                self.cb_plot_channel_1_process_signals.addItem(str(i))
                self.cb_plot_channel_2_process_signals.addItem(str(i))
            
            # Set default selections
            self.cb_plot_channel_1_process_signals.setCurrentIndex(0)  # First channel
            self.cb_plot_channel_2_process_signals.setCurrentIndex(1)  # Second channel
            
            self.wav_filter.setText(str(df.loc["filter_to_use", "Value"]))
            self.levels_of_wav_filter.setCurrentText(str(df.loc["levels_to_use", "Value"]))
            self.layers_to_use.setCurrentText(str(len(ast.literal_eval(df.loc["layers_to_catch", "Value"]))))
            self.type_of_matrix.setCurrentText(str(df.loc["type_matrix", "Value"]))
            self.test_size.setText(str(df.loc["test_size", "Value"]))
            self.random_state.setText(str(df.loc["random_state", "Value"]))
            self.cv.setText(str(df.loc["cv", "Value"]))
            self.file_path_label.setText(str(df.loc["file", "Value"]))
            
            # Set filter paths
            self.filter_1_path.setText("Parameters/sos_highpass_filter.csv")
            self.filter_2_path.setText("Parameters/sos_bandstop_filter.csv")
            
        except Exception as e:
            print(f"Error loading default values: {e}")

    def train_data(self, store=False, **kwargs) -> None:
        """
        Function used to train data
        :param store: bool -> set this to True to save .joblib files
        :param kwargs: dict -> dictionary containing the parameters for classifier
        :return: None
        """
        self.data_and_classifiers = train_signals_emg.train_signals_emg(store, **kwargs)

    def train_myo(self) -> None:
        """
        Function responsible to train the classifiers for the first time and save the .joblib files
        :return: None
        """
        # store useful information regarding the classifiers
        # self.data_and_classifiers = train_signals_emg.train_signals_emg()
        self.train_data(store=True)
        # Indicate that the classifiers have already been trained
        self.trained_sys = True
        # Read the scores achieved in the classifiers
        df = pd.read_csv("scores_of_classifiers.csv")
        # Store the scores
        values = df["Scores"]
        # PyQt5 parameter to populate the treeWidget table
        _translate = QtCore.QCoreApplication.translate
        # update the scores in the table
        for i, j in enumerate(values):
            value = j * 100
            self.treeWidget.topLevelItem(i).setText(1, _translate("Form", f"{value:.2f}%"))
        # Plot the scores in the graph
        self.main_classifier()
        self.data_successfully_trained_msg()

    def main_classifier(self) -> None:
        """
        Plot the scores of the classifiers in the graph of the Home Window page
        :return: None
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            self.figure_3.clear()
            df = pd.read_csv("scores_of_classifiers.csv")
            classifiers = df["Classifiers"]
            values = df["Scores"] * 100

            ax3 = self.figure_3.add_subplot(111)
            bars = ax3.bar(classifiers, values, color='#3498db')
            
            # Add value labels on top of bars
            for bar in bars:
                height = bar.get_height()
                ax3.text(bar.get_x() + bar.get_width()/2., height + 1,
                        f'{height:.1f}%', ha='center', va='bottom', fontweight='bold')
                
            ax3.set_title('Scores of the classifiers', fontsize=14, fontweight='bold')
            ax3.set_xlabel('Classifiers', fontsize=12)
            ax3.set_ylabel('Scores %', fontsize=12)
            ax3.grid(axis='y', linestyle='--', alpha=0.7)
            ax3.spines['top'].set_visible(False)
            ax3.spines['right'].set_visible(False)
            
            # Set y-axis to start from 0 and have some headroom above max value
            max_value = max(values)
            ax3.set_ylim(0, max_value * 1.1)

            # refresh canvas
            self.canvas_main_classifier.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def refresh_params(self) -> None:
        """
        Update the file parameters.csv that is storing the parameters of training the classifiers
        """
        frequency = self.frequency.text()
        window_time = self.window_time.text()
        n_of_channels = self.n_of_channels.currentText()
        filter_1_path = self.filter_1_path.text()
        filter_2_path = self.filter_2_path.text()
        wav_filter = self.wav_filter.text()
        levels_of_filter = self.levels_of_wav_filter.currentText()
        layers_to_use_num = int(self.layers_to_use.currentText())
        layers_to_use = []
        for i in range(layers_to_use_num):
            layers_to_use.append(i + 1)

        type_of_matrix = self.type_of_matrix.currentText()
        test_size = self.test_size.text()
        random_state = self.random_state.text()
        cv = self.cv.text()
        raw_file_data = self.file_path_label.text()

        filter_1_df = pd.read_csv(filter_1_path, index_col="Filter")
        filter_2_df = pd.read_csv(filter_2_path, index_col="Filter")

        filter_1 = filter_1_df.loc["sos_high_pass_", "Value"]
        filter_2 = filter_2_df.loc["sos_bandstop_", "Value"]

        df = pd.read_csv("Parameters/parameters.csv", index_col="Parameter")

        df.loc["frequency_of_capture", "Value"] = frequency
        df.loc["window_time", "Value"] = window_time
        df.loc["n_of_channels_and_category", "Value"] = n_of_channels
        df.loc["sos_high_pass_", "Value"] = filter_2
        df.loc["sos_bandstop_", "Value"] = filter_1
        df.loc["layers_to_catch", "Value"] = layers_to_use
        df.loc["levels_to_use", "Value"] = levels_of_filter
        df.loc["filter_to_use", "Value"] = wav_filter
        df.loc["type_matrix", "Value"] = type_of_matrix
        df.loc["test_size", "Value"] = test_size
        df.loc["random_state", "Value"] = random_state
        df.loc["cv", "Value"] = cv
        df.loc["file", "Value"] = raw_file_data
        df.to_csv("Parameters/parameters.csv")
        
        # Reload parameters
        self.params = ParametersToUse()

        # Update comboboxes dynamically
        self.update_channel_comboboxes(int(n_of_channels))
        
        # Update UI with success message
        self.parameters_updated_msg()

    def find_path_filter_1(self) -> None:
        """
        Show the user a dialog box to choose the highpass filter file
        """
        # self.file_path_label.setText("This path")
        # Open a File Dialog
        if "PYCHARM_HOSTED" in os.environ:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)",
                options=QtWidgets.QFileDialog.DontUseNativeDialog
            )
        else:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)"
            )
        if ret:
            self.filter_1_path.setText(ret)

    def find_path_filter_2(self) -> None:
        """
        Show the user a dialog box to choose the bandstop filter file
        """
        # self.file_path_label.setText("This path")
        # Open a File Dialog
        if "PYCHARM_HOSTED" in os.environ:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)",
                options=QtWidgets.QFileDialog.DontUseNativeDialog
            )
        else:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Parameters/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)"
            )
        if ret:
            self.filter_2_path.setText(ret)

    def find_path_file(self) -> None:
        """
        Show the user a dialog box to choose the raw data EMG to train the classifiers
        """
        # self.file_path_label.setText("This path")
        # Open a File Dialog
        if "PYCHARM_HOSTED" in os.environ:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Raw_EMG_Data/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)",
                options=QtWidgets.QFileDialog.DontUseNativeDialog
            )
        else:
            ret, _ = QtWidgets.QFileDialog.getOpenFileName(
                None, 'Open File',
                'Raw_EMG_Data/', "All Files (*);;Python Files (*.py);;Csv Files (*.csv)"
            )
        if ret:
            self.file_path_label.setText(ret)

    def plot_confusion_matrix(self) -> None:
        """
        Plots Confusion Matrix based in the defined classifier
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            self.train_data()

            self.figure_2.clear()
            classifiers = {'knn': self.data_and_classifiers.knn,
                           'lda': self.data_and_classifiers.lda,
                           'gnb': self.data_and_classifiers.gnb,
                           'tree': self.data_and_classifiers.tree,
                           'lin_svm': self.data_and_classifiers.lin_svm}

            conf_classifier = self.confusion_matrix_classifier_cb.currentText()
            conf_type = self.confusin_matrix_type_cb.currentText()
            if conf_type == 'None':
                conf_type = None
            # https://stackoverflow.com/questions/19233771/sklearn-plot-confusion-matrix-with-labels
            ax4 = self.figure_2.add_subplot(111)
            disp = ConfusionMatrixDisplay.from_estimator(classifiers[conf_classifier],
                                                  self.data_and_classifiers.m_class_test_independentVars,
                                                  self.data_and_classifiers.m_class_test_target_vars,
                                                  ax=ax4,
                                                  normalize=conf_type,
                                                  cmap='Blues')

            ax4.set(xlabel='Predicted', ylabel='True', title='Confusion Matrix True vs Predicted')
            ax4.title.set_fontsize(14)
            ax4.title.set_fontweight('bold')
            ax4.xaxis.label.set_fontsize(12)
            ax4.yaxis.label.set_fontsize(12)

            # refresh canvas
            self.canvas_conf_matrix.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def data_classifiers_to_use(self):
        classifiers = {'knn': self.data_and_classifiers.knn,
                       'lda': self.data_and_classifiers.lda,
                       'gnb': self.data_and_classifiers.gnb,
                       'tree': self.data_and_classifiers.tree,
                       'lin_svm': self.data_and_classifiers.lin_svm}
        return classifiers

    def choose_classifier(self, classifier, number=None) -> None:
        if classifier == "lda":
            use_ = {"lda": number / 10}
            self.train_data(**use_)
        elif classifier == "knn":
            use_ = {"knn": number}
            self.train_data(**use_)
        elif classifier == "tree":
            use_ = {"tree": number}
            self.train_data(**use_)
        else:
            self.train_data()

    def plot_roc_curve(self) -> None:
        """
        Plot ROC curve if the data has already been trained and it's a data with just two categories
        """
        # Check if the classifiers have already been trained

        if self.data_and_classifiers is not None:
            # Check if it just has 2 classes
            if len(np.unique(self.data_and_classifiers.m_class_test_target_vars)) <= 2:
                self.figure_4.clear()
                # Define the subplot figure
                ax5 = self.figure_4.add_subplot(111)
                # Store the classifiers in a dictionary

                use_ = {"lda": 0.5}
                self.train_data(**use_)
                classifiers = {'knn': self.data_and_classifiers.knn,
                              'lda': self.data_and_classifiers.lda,
                              'gnb': self.data_and_classifiers.gnb,
                              'tree': self.data_and_classifiers.tree,
                              'lin_svm': self.data_and_classifiers.lin_svm}

                # Define the colors to be used in the plot
                colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6']
                
                # Plot ROC curve for each classifier
                for i, (name, clf) in enumerate(classifiers.items()):
                    y_pred = clf.predict_proba(self.data_and_classifiers.m_class_test_independentVars)[:, 1]
                    fpr, tpr, _ = roc_curve(self.data_and_classifiers.m_class_test_target_vars, y_pred)
                    auc = roc_auc_score(self.data_and_classifiers.m_class_test_target_vars, y_pred)
                    ax5.plot(fpr, tpr, color=colors[i], lw=2,
                            label=f'{name} (AUC = {auc:.2f})')

                # Plot the random guessing line
                ax5.plot([0, 1], [0, 1], color='gray', lw=1, linestyle='--', 
                        label='Random guessing')

                # Set labels and title
                ax5.set_xlabel('False Positive Rate', fontsize=12)
                ax5.set_ylabel('True Positive Rate', fontsize=12)
                ax5.set_title('Receiver Operating Characteristic (ROC) Curve', 
                             fontsize=14, fontweight='bold')
                
                # Add grid and legend
                ax5.grid(linestyle='--', alpha=0.7)
                ax5.legend(loc='lower right', fontsize=10)
                
                # Set axis limits
                ax5.set_xlim([-0.01, 1.01])
                ax5.set_ylim([-0.01, 1.01])
                
                # Remove top and right spines
                ax5.spines['top'].set_visible(False)
                ax5.spines['right'].set_visible(False)

                # refresh canvas
                self.canvas_roc_curve.draw()
            # Show a message box indicating that the data has more than 2 classes
            else:
                self.more_than_two_classes_msg()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def raw_signals_plot(self) -> None:
        """
        Plot the Raw data signal channel selected
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            # clear the canvas
            self.figure.clear()
            # Select the channel to plot the graph
            channel_1 = int(self.cb_raw_signal_1.currentText())
            # Read the Raw Data EMG
            df = pd.read_csv(self.file_path_label.text())
            # Plot raw data values
            self.plot_values_of_channels_raw_emg(df, channel_1)
            # refresh canvas
            self.canvas_raw_signals.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def plot_values_of_channels_raw_emg(self, df, col1) -> None:
        """
        Plot Raw data for each channel
        :param df: dataframe used to store raw data EMG
        :param col1: column to plot representing the EMG channel
        :return: None
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            ax2 = self.figure.add_subplot(111)
            x = np.arange(len(df))
            y = df[df.columns[col1 + 1]]
            
            # Plot with improved styling
            ax2.plot(x, y, linewidth=1.5, color='#3498db')
            
            # Add grid for better readability
            ax2.grid(True, linestyle='--', alpha=0.7)
            
            # Remove top and right spines for cleaner look
            ax2.spines['top'].set_visible(False)
            ax2.spines['right'].set_visible(False)
            
            # Improve title and labels
            ax2.set_title(f'Values in Channel_{col1} and the number of the sample', 
                         fontsize=14, fontweight='bold')
            ax2.set_xlabel(f'Number of the sample - value', fontsize=12)
            ax2.set_ylabel(f'Channel_{col1} - value(mv)', fontsize=12)
            
            # Add some padding to the plot
            ax2.margins(0.01)
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def classified_signals(self) -> None:
        """
        Plot the processed data based on the channels selected
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            # clear the canvas
            self.figure_1.clear()
            
            try:
                # Read the processed data
                df = pd.read_csv("M_Class_Data/training_matrix_csv_m_class.csv")
                
                # Get the number of channels from parameters
                n_channels = self.params.n_of_channels_and_category
                print(f"Number of channels from parameters: {n_channels}")
                
                # Print current items in comboboxes
                print("Channel 1 combobox items:", [self.cb_plot_channel_1_process_signals.itemText(i) for i in range(self.cb_plot_channel_1_process_signals.count())])
                print("Channel 2 combobox items:", [self.cb_plot_channel_2_process_signals.itemText(i) for i in range(self.cb_plot_channel_2_process_signals.count())])
                
                # Clear and update the channel selection comboboxes
                #self.cb_plot_channel_1_process_signals.clear()
                #self.cb_plot_channel_2_process_signals.clear()
                
                # Add only the available channels to the comboboxes
               ## for i in range(1, n_channels + 1):
                   # self.cb_plot_channel_1_process_signals.addItem(str(i))
                   # self.cb_plot_channel_2_process_signals.addItem(str(i))
                
                channel_1 = int(self.cb_plot_channel_1_process_signals.currentText())
                channel_2 = int(self.cb_plot_channel_2_process_signals.currentText())
                
                print("After updating comboboxes:")
                print("Channel 1 combobox items:", [self.cb_plot_channel_1_process_signals.itemText(i) for i in range(self.cb_plot_channel_1_process_signals.count())])
                print("Channel 2 combobox items:", [self.cb_plot_channel_2_process_signals.itemText(i) for i in range(self.cb_plot_channel_2_process_signals.count())])
                
                # Get the selected channel numbers from the comboboxes
                channel_1 = int(self.cb_plot_channel_1_process_signals.currentText())
                print(f"Selected channel 1: {channel_1}")
                channel_2 = int(self.cb_plot_channel_2_process_signals.currentText())
                print(f"Selected channel 2: {channel_2}")
                
                # Get column names based on the dataframe's actual column names
                # First, find columns that contain "Chanel" or "Channel"
                channel_columns = [col for col in df.columns if "Chanel" in col or "Channel" in col]
                print("Available channel columns:", channel_columns)
                
                # If we found channel columns, use them
                if channel_columns:
                    # Sort the channel columns to ensure proper ordering
                    channel_columns.sort()
                    
                    # Make sure we don't exceed the available channels
                    if channel_1 <= len(channel_columns) and channel_2 <= len(channel_columns):
                        # Get the actual column names for the selected channels
                        col1_name = channel_columns[channel_1 - 1]
                        col2_name = channel_columns[channel_2 - 1]
                        
                        print(f"Using columns: {col1_name} and {col2_name}")
                        
                        # Create display names for the channels (for labels and title)
                        col1_display = f"Channel_{channel_1}"
                        col2_display = f"Channel_{channel_2}"
                        
                        # Verify columns exist in the dataframe
                        if col1_name in df.columns and col2_name in df.columns:
                            # Pass both the actual column names and the display names
                            self.plot_values_of_channels_process_emg(df, col1_name, col2_name, col1_display, col2_display)
                        else:
                            print(f"Error: Columns {col1_name} or {col2_name} not found in dataframe")
                            self.show_error_message(f"Columns {col1_name} or {col2_name} not found in dataframe")
                    else:
                        print(f"Error: Selected channels exceed available channels")
                        self.show_error_message("Selected channels exceed available channels")
                else:
                    print("Error: No channel columns found in the dataframe")
                    self.show_error_message("No channel columns found in the dataframe")
                
            except Exception as e:
                print(f"Error in classified_signals: {e}")
                self.show_error_message(f"Error: {str(e)}")
            
            # refresh canvas
            self.canvas_process_signals.draw()
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def update_channel_comboboxes(self, n_channels: int):
        """
        Dynamically update channel selection comboboxes based on the number of channels.
        This should be called only when the number of channels changes.
        """
        if self.cb_plot_channel_1_process_signals.count() == n_channels:
            return  # Already up-to-date

        print("Updating ComboBoxes!")

        self.cb_plot_channel_1_process_signals.blockSignals(True)
        self.cb_plot_channel_2_process_signals.blockSignals(True)

        self.cb_plot_channel_1_process_signals.clear()
        self.cb_plot_channel_2_process_signals.clear()

        for i in range(1, n_channels + 1):
            self.cb_plot_channel_1_process_signals.addItem(str(i))
            self.cb_plot_channel_2_process_signals.addItem(str(i))

        # Optional: set default selection to 1 and 2 (or same if only 1 channel)
        self.cb_plot_channel_1_process_signals.setCurrentIndex(0)
        self.cb_plot_channel_2_process_signals.setCurrentIndex(1 if n_channels > 1 else 0)

        self.cb_plot_channel_1_process_signals.blockSignals(False)
        self.cb_plot_channel_2_process_signals.blockSignals(False)


    def plot_values_of_channels_process_emg(self, df, col1_name, col2_name, col1_display, col2_display) -> None:
        """
        Plot the processed data parameters
        :param df: dataframe containing the processed data
        :param col1_name: name of the first column to plot (X axis)
        :param col2_name: name of the second column to plot (Y axis)
        :param col1_display: display name for the first channel (for labels and title)
        :param col2_display: display name for the second channel (for labels and title)
        """
        # Check if the classifiers have already been trained
        if self.data_and_classifiers is not None:
            try:
                # Define the subplot figure
                ax1 = self.figure_1.add_subplot(111)
                # Define parameters and values of the categories
                categories = df["Category"].unique()
                # Modern color palette
                colors = ["#3498db", "#e74c3c", "#2ecc71", "#f39c12", "#9b59b6", 
                         "#1abc9c", "#d35400", "#34495e", "#7f8c8d", "#c0392b"]
                category = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']
                
                # Plot each category with improved styling
                for i, j in enumerate(categories):
                    mask = df["Category"] == j
                    df_x = df[mask]
                    
                    # Plot the data points
                    ax1.scatter(x=df_x[col1_name], y=df_x[col2_name], 
                               color=colors[i % len(colors)], label=f"Category: {category[i]}", 
                               alpha=0.7, edgecolors='w', s=60)
                
                # Improve title and labels - use the display names instead of column names
                ax1.set_title(f'Processed Signals: {col1_display} vs {col2_display}', 
                             fontsize=14, fontweight='bold')
                ax1.set_xlabel(f'{col1_display}', fontsize=12)
                ax1.set_ylabel(f'{col2_display}', fontsize=12)
                
                # Add grid and legend
                ax1.grid(True, linestyle='--', alpha=0.3)
                ax1.legend(loc='best', frameon=True, fancybox=True, framealpha=0.7, 
                          fontsize=10)
                
                # Remove top and right spines
                ax1.spines['top'].set_visible(False)
                ax1.spines['right'].set_visible(False)
                
            except Exception as e:
                print(f"Error in plot_values_of_channels_process_emg: {e}")
                self.show_error_message(f"Error plotting: {str(e)}")
        # Show a message box indicating that the classifiers have not been trained
        else:
            self.not_trained_model()

    def show_error_message(self, message):
        """
        Show an error message box
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Critical)
        msg.setText(message)
        msg.setWindowTitle("Error")
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msg.exec_()

    def not_trained_model(self) -> None:
        """
        Show a message box indicating that the classifiers have not been trained
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Critical)
        msg.setText("The classifiers have not been trained yet")
        msg.setWindowTitle("Error")
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msg.exec_()

    def more_than_two_classes_msg(self) -> None:
        """
        Show a message box indicating that the data has more than 2 classes
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Critical)
        msg.setText("The data has more than 2 classes")
        msg.setInformativeText("ROC curve is only available for binary classification problems")
        msg.setWindowTitle("Error")
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msg.exec_()

    def data_successfully_trained_msg(self) -> None:
        """
        Show a message box indicating that the data has been successfully trained
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Information)
        msg.setText("The data has been successfully trained")
        msg.setWindowTitle("Success")
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msg.exec_()

    def parameters_updated_msg(self) -> None:
        """
        Show a message box indicating that the parameters have been successfully updated
        """
        msg = QtWidgets.QMessageBox()
        msg.setIcon(QtWidgets.QMessageBox.Information)
        msg.setText("The parameters have been successfully updated")
        msg.setWindowTitle("Success")
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msg.exec_()


def main():
    app = QtWidgets.QApplication(sys.argv)
    window = EmgApplication()
    window.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
